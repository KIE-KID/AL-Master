# 자료구조

데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장하거나 조작하는 방법으로 각각의 자료 구조의 장단점을 이해하고 목적에 맞는 자료구조를 사용해야한다.

=어떤 상황에서 어떤 자료 구조가 가장 적합한지 파악하고 사용해야한다!

## 1. Array (배열)

### 특징

- 인덱스-원소값( index,value )의 쌍으로 구성
- **같은 타입**의 데이터를 나열한 **선형 자료구조 (sequence container)**
- 항목을 순차적으로 **연속된 메모리 공간**에 순차적으로 저장
- 배열의 **크기는 고정**. 선언할 때에 배열의 크기를 정하고, 변경할 수 없다.

### 시간 복잡도

- 배열의 맨 앞에 삽입/삭제하는 경우 : O(n)
- 배열의 중간에 삽입/삭제하는 경우 : O(n)
- 배열의 맨 뒤에 삽입/삭제하는 경우 : O(1)
- 탐색(인덱스로 해당 원소에 바로 접근 가능): O(1)

*삭제 또는 삽입, 배열의 어느 원소를 삭제하면 배열의 연속적인 특징이 깨져 빈 공간이 생긴다. 따라서 해당 원소에 접근하는 비용(O(1))에 추가로 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift` 하는 비용(cost)이 발생해서 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 된다. 삽입도 마찬가지로 새로운 원소를 추가할 때 모든 원소들의 인덱스를 1 씩 `shift` 해야 하므로  O(n)의 시간이 필요하다.*

### 장점

- **Random Access**  인덱스를 가지고 있어 원소로 바로 접근 가능 (시간복잡도 O(1))
- **연속된 메모리 공간**에 존재하기 때문에 정적인 자료는 관리하기가 편하다.

### 단점

- 삽입과 삭제가 어렵고 오래 걸린다.
- 원소 삽입 혹은 삭제 시, 해당 원소 이후의 모든 원소들을 한칸씩 밀거나 당겨야 한다.(연산량 증가)
- 배열은 처음 생성할 때 크기를 설정하고 크기를 바꿀 수 없다.
- 배열의 크기를 프로그램 실행전에 최대크기로 선언해야 함 (런타임에 확장 불가)
- 크기를 변경하기 위해서는 원하는 크기의 새로운 배열을 선언한 뒤 값을 복사해야 함.
- 연속된 메모리라서 공간 낭비가 발생할 수 있다.
- 중간에 데이터가 삭제되면 공간 낭비가 발생할 수 있음. 또, 선언한 크기보다 적게 사용하면 낭비가 발생함.

### 사용

- 순차 데이터 저장할 때 (ex. 주식, 대회 결과, 날씨 등)
- 다차원 데이터를 다룰 때 (ex. 배열 안의 배열)
- 특정 요소를 빠르게 읽어야할 때 (ex. index로 바로 불러오는 경우)
- 데이터 사이즈가 (거의) 바뀌지 않을 때
- 데이터가 자주 삭제 되거나 추가되지 않을 때


## 2.Stack
<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/53163222/115954760-b6910200-a52d-11eb-8222-ad612c2ded7e.png">
</p>
차곡차곡 쌓아 올린 형태의 자료구조
후입선출(LIFO, Last-in First-out)

### 특징
- 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있다.
- top으로 정한 곳을 통해서만 접근할 수 있다.
- top은 가장 위에 있는 최근에 들어온 자료를 가리키고 있다.
- top을 통해서 자료를 삭제할 수 있다.
- top을 통해 삽입하는 연산을 push
- top을 통해 삭제하는 연산을 pop
- 시간 순서에 따라 자료가 쌓여서 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조 = 

stack underflow: 비어있는 스택에서 원소를 추출하려고 할때 
stack overflow: 스택이 넘치는 경우

### 시간 복잡도
- 삽입 : O(1)
- 삭제 : O(1)
- 탐색 : O(N)
### 장점
### 단점
### 사용

웹 브라우저 방문기록 (뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력한다.
실행 취소 (undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
후위 표기법 계산
수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)

## 3. Queue
<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/53163222/115955246-65ced880-a530-11eb-9a8b-4458a07c2d2a.png ">
</p>

### 특징
선입선출(FIFO, First-in First-out)
rear, front가 존재

### 시간 복잡도
- 삽입 : O(1)
- 삭제 : O(1)
- 탐색 : O(N)

### 장점
### 단점
### 사용
큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.

우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
은행 업무
콜센터 고객 대기시간
프로세스 관리
너비 우선 탐색(BFS, Breadth-First Search) 구현
캐시(Cache) 구현
