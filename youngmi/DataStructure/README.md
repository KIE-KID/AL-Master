# 자료구조

데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장하거나 조작하는 방법으로 각각의 자료 구조의 장단점을 이해하고 목적에 맞는 자료구조를 사용해야한다.

=어떤 상황에서 어떤 자료 구조가 가장 적합한지 파악하고 사용해야한다!

## 1. Array (배열)

### 특징

- 인덱스-원소값( index,value )의 쌍으로 구성
- **같은 타입**의 데이터를 나열한 **선형 자료구조 (sequence container)**
- 항목을 순차적으로 **연속된 메모리 공간**에 순차적으로 저장
- 배열의 **크기는 고정**. 선언할 때에 배열의 크기를 정하고, 변경할 수 없다.

### 시간 복잡도

- 배열의 맨 앞에 삽입/삭제하는 경우 : O(n)
- 배열의 중간에 삽입/삭제하는 경우 : O(n)
- 배열의 맨 뒤에 삽입/삭제하는 경우 : O(1)
- 탐색(인덱스로 해당 원소에 바로 접근 가능): O(1)

*삭제 또는 삽입, 배열의 어느 원소를 삭제하면 배열의 연속적인 특징이 깨져 빈 공간이 생긴다. 따라서 해당 원소에 접근하는 비용(O(1))에 추가로 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift` 하는 비용(cost)이 발생해서 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 된다. 삽입도 마찬가지로 새로운 원소를 추가할 때 모든 원소들의 인덱스를 1 씩 `shift` 해야 하므로  O(n)의 시간이 필요하다.*

### 장점

- **Random Access**  인덱스를 가지고 있어 원소로 바로 접근 가능 (시간복잡도 O(1))
- **연속된 메모리 공간**에 존재하기 때문에 정적인 자료는 관리하기가 편하다.

### 단점

- 삽입과 삭제가 어렵고 오래 걸린다.
- 원소 삽입 혹은 삭제 시, 해당 원소 이후의 모든 원소들을 한칸씩 밀거나 당겨야 한다.(연산량 증가)
- 배열은 처음 생성할 때 크기를 설정하고 크기를 바꿀 수 없다.
- 배열의 크기를 프로그램 실행전에 최대크기로 선언해야 함 (런타임에 확장 불가)
- 크기를 변경하기 위해서는 원하는 크기의 새로운 배열을 선언한 뒤 값을 복사해야 함.
- 연속된 메모리라서 공간 낭비가 발생할 수 있다.
- 중간에 데이터가 삭제되면 공간 낭비가 발생할 수 있음. 또, 선언한 크기보다 적게 사용하면 낭비가 발생함.

### 사용

- 순차 데이터 저장할 때 (ex. 주식, 대회 결과, 날씨 등)
- 다차원 데이터를 다룰 때 (ex. 배열 안의 배열)
- 특정 요소를 빠르게 읽어야할 때 (ex. index로 바로 불러오는 경우)
- 데이터 사이즈가 (거의) 바뀌지 않을 때
- 데이터가 자주 삭제 되거나 추가되지 않을 때

<br>
***스택과 큐는 리스트 자료구조의 특별한 경우이다.***

## 2.Stack
<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/53163222/116805512-fd9c7a00-ab61-11eb-8c11-96e37b2942d2.png">
</p>

차곡차곡 쌓아 올린 형태의 자료구조
후입선출(LIFO, Last-in First-out)
시간 순서에 따라 자료가 쌓여서 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조  

### 특징
- 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있다.
- top은 가장 위에 있는 최근에 들어온 자료를 가리키고 있다.
- top으로 정한 곳을 통해서만 접근하고 연산할 수 있다.


- push: top을 통해 데이터를 삽입하는 연산
- pop: top을 통해 데이터를 삭제하는 연산
- stack underflow: 비어있는 스택에서 원소를 추출하려고 할때 
- stack overflow: 스택이 넘치는 경우

<br>
*stack을 배열 또는 연결리스트 혹은 그 외의 것을 이용하여 구현할 수 있다.
stack 자체는 정의이기 때문에 다양한 자료구조를 통해 구현 가능하다!*

### 시간 복잡도
- 삽입 : O(1)
- 삭제 : O(1)
- 탐색 : O(N)

### 사용
웹 브라우저 방문기록 (뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력한다.
실행 취소 (undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
후위 표기법 계산
수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
DFS 구현 (depth first search) - 내가 현재 있는 위치에서 이동할 수 있는 위치를 stack에 모두 넣고 꺼내는 식으로 풀이 가능


## 3. Queue
<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/53163222/116805527-14db6780-ab62-11eb-891d-db6f490c9012.png">
</p>

### 특징
선입선출(FIFO, First-in First-out)
rear, front가 존재

### 시간 복잡도
- 삽입 : O(1)
- 삭제 : O(1)
- 탐색 : O(N)

### 사용
주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용
우선순위가 같은 작업 (프린터의 인쇄 대기열)
은행 업무, 콜센터 업무
프로세스 관리
너비 우선 탐색(BFS, Breadth-First Search) 구현 - 내가 현재 있는 위치에서 이동할 수 있는 위치를 queue에 모두 넣고 꺼내는 식으로 풀이 가능
캐시(Cache) 구현


## 3-1. Deque (데크)
double-ended queue 의 줄임말로, 앞과 뒤에서 즉, 양방햐에서 데이터를 처리할 수 있는 queue형 자료구조를 의미한다.
<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/53163222/116805516-00976a80-ab62-11eb-8bbf-accd184a6eed.png">
</p>

python의 collections에서 deque를 제공하고 있는데, 여기서 deque는 list와 일부 유사하다.
자세한 메소드 활용 코드는 [여기](python/deque.py)에서 확인할 수 있다.
deque의 전체 메소드는 [여기](docs.python.org)에서 확인할 수 있다.

## 3-2. Priority Queue (우선순위 큐)
일반적으로 선입선출(FIFO)의 구조인 큐와 달리 들어간 순서에 상관없이 우선순위가 높은 데이터가 큐에서 먼저 나오는 자료구조를 말한다.
힙(heap)이라는 자료구조로 구현할 수 있다.
<p align="center">
<img width="50%" src="">
</p>

Q. 왜 배열이나 연결리스트로 구현하지 않을까?
- 배열로 구현하는 경우: 