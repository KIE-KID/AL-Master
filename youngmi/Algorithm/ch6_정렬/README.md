# 정렬(Sorting)

데이터를 특정한 기준에 따라 순서대로 나열하는 것<br>
일반적으로 문제 상황에 따라서 적절한 알고리즘이 공식처럼 사용된다.
c.f) 데이터의 개수가 적을 때, 데이터 개수가 많더라도 데이터 범위가 한정적일 때, 이미 정렬되어 있는 경우 등...

사람은 직관적으로 데이터를 파악하고 계산할 수 있지만 컴퓨터는 정렬을 어떻게 수행할지 알고리즘을 구체적으로 명시해야한다.

##  1. 선택 정렬
처리되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것**을 반복한다.

### 동작 예시

초기 데이터: 7 5 9 0 3 1 6 2 4 8

[step 1] 처리되지 않은 데이터(1~10) 중에서 가장 작은 '0'을 선택해 가장 앞에 있는 '7'과 바꾼다.

→  '0' 정렬 완료  

[step 2] 정렬된 데이터를 제외하고 처리되지 않은 데이터(2~10) 중에서 가장 작은 '1'을 선택해 가장 앞에 있는 '5'와 바꾼다.

→  '0', '1' 정렬 완료
 
[step 3] 정렬된 데이터를 제외하고 처리되지 않은 데이터(3~n) 중에서 가장 작은 '2'를 선택해 가장 앞에 있는 '9'와 바꾼다.

→  '0', '1', '2' 정렬 완료

<p align="center">
---------- 중략 ----------
<br>
<br>
</p>

[step 10] 위의 과정을 총 9번 반복하면 마지막 데이터는 가만히 두어도 이미 정렬된 상태이므로, 이 단계에서 정렬이 완료된다.

→  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 정렬 완료

### 시간 복잡도
- 탐색 범위는 반복할 때마다 1씩 줄어든다.
- 데이터를 앞으로 보내는 과정은 N-1번 반복한다.
- 매번 탐색 범위만큼 데이터를 하나씩 확인하고 비교해서 가장 작은 데이터를 찾는다(선형탐색).
- 선택 정렬은 이중 반복문으로 구현가능하다. = 직관적으로 이해하면, 소스코드 상에 이중 반복문으로 O(N²)이 되었다고 할 수 있다.

구현방식에 따라 사소한 오차는 있을 수 있지만 위의 방식대로 한다면, 연산 횟수는 다음과 같다.
 N + ( N - 1 ) + ( N - 2 ) + ··· + 2 &nbsp; ≒&nbsp; N × ( N + 1 ) / 2 &nbsp;=&nbsp; ( N² + N ) / 2

<big>***Big-O Notation: O(N²)***</big>

### Q. 선택 정렬은 효율적인가?

정렬할 데이터 개수가 100배 늘어나면 이론적으로 수행 시간은 10,000배 늘어난다.
선택 정렬, 퀵 정렬, 기본 정렬 라이브러리의 수행시간을 비교해보면 다음과 같다.(초 단위, 측정 시간은 컴퓨터마다 다를 수 있음)

<small>* 아래 표는 Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz, 2코어 환경에서 측정</small>
<table class="tg">
<thead>
  <tr style="text-align:center">
    <th class="tg-kr4b">데이터 개수(N)</th>
    <th class="tg-acii">선택 정렬</th>
    <th class="tg-acii">퀵 정렬</th>
    <th class="tg-0pky">기본 정렬 라이브러리</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-acii">N = 100</td>
    <td class="tg-acii" style="text-align:right">0.0123</td>
    <td class="tg-acii" style="text-align:right"> 0.00156</td>
    <td class="tg-0pky" style="text-align:right">0.00000753</td>
  </tr>
  <tr>
    <td class="tg-dude">N = 1,000</td>
    <td class="tg-dude" style="text-align:right">0.354</td>
    <td class="tg-dude" style="text-align:right">0.00343</td>
    <td class="tg-0pky" style="text-align:right">0.0000365</td>
  </tr>
  <tr>
    <td class="tg-acii" >N = 10,000</td>
    <td class="tg-acii" style="text-align:right">15.475</td>
    <td class="tg-acii" style="text-align:right">0.0312</td>
    <td class="tg-0pky" style="text-align:right">0.000248</td>
  </tr>
</tbody>
</table>

선택 정렬을 이용하면 데이터 개수가 10,000개 이상일 때 정렬 속도가 급격히 느려지는 것을 확인할 수 있다.
파이썬에 내장된 기본 정렬 라이브러리는 내부적으로 C언어 기반이면 다양한 최적화 테크닉이 포함되어 더욱 빠르게 동작한다.

선택 정렬은 기본 정렬 라이브러리, 다른 알고리즘과 비교했을 때 매우 비효율적이다.
<u>다만, 특정 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦기때문에 이러한 형태의 소스코드에 익숙해질 필요가 있다.</u>
선택 정렬 소스코드를 자주 작성해볼 것을 권장!


선택 정렬은 알고리즘 문제 풀이에 사용하기에는 느린 편이다. 그렇다면 다른 접근 방법은 무엇이 있는지 생각해보자.

## 2. 삽입 정렬

처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입** 한다.
선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.
(선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘)

선택 정렬은 현재 데이터 상태와는 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면, 
삽입 정렬은 필요할 때만 위치를 바꾸므로 **'데이터가 거의 정렬 되어 있을 때'** 훨씬 효율적이다.

### 특징
- 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
- 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다.
- 두 번째 데이터부터 시작한다. 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단.

### 동작 예시

초기 데이터: 7 5 9 0 3 1 6 2 4 8

첫 번째 데이터 '7'은 이미 정렬이 되어있다고 판단.

[step 1] 두 번째 데이터 '5'가 어느 위치로 들어갈지 판단한다.'7'의 왼쪽 혹은 오른쪽 두 경우만 존재한다. 오름차순 정렬을 하는 경우 이므로 '7'의 왼쪽에 삽입.

→  '5', '7' 정렬 완료  

[step 2] 세 번째 데이터 '9'가 어느 위치로 들어갈지 판단한다. 삽입될 수 있는 위치는 총 3 가지이며 '9'는 '5', '7'보다 크기 때문에 원래 자리 그대로 둔다.

→  '5', '7', '9' 정렬 완료  
 
[step 3] 네 번째 데이터 '0'이 어느 위치로 들어갈지 판단한다. 삽입될 수 있는 위치는 총 4 가지이며, '0'은 '5', '7', '9'와 비교했을 때 가장 작기 때문에 첫 번째 위치에 삽입한다.

→  '0', '5', '7', '9' 정렬 완료

<p align="center">
---------- 중략 ----------
<br>
<br>
</p>
[step 10] 위의 과정을 총 9(n-1)번 반복하면 모든 데이터의 정렬이 완료된다.

→  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 정렬 완료

*삽입 정렬은 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있기때문에 특정한 데이터가 삽입될 위치를 선정할 때(삽입될 위치를 찾기 위해 왼족으로 한 칸씩 이동할 때), 삽입될 데이터보다 작은 데이터를 만나면
그 위치에서 멈추면 된다.*

다시말해, 특정 데이터 왼쪽에 있는 데이터들은 이미 정렬이 된 상태이므로 자기보다 작은 데이터를 만났을 때는 더 이상 살펴볼 필요가 없다.

### 시간 복잡도

삽입 정렬은 선택 정렬과 마찬가지로 이중 반복문을 사용하므로 시간 복잡도는 O(N²)라고 할 수 있다.(반복문 안에서 비교연산과 swapping 수행) 실제로 수행시간을 테스트해보면 선택 정렬과 흡사한 시간이 소요되는 것을 알 수 있다.
하지만, **삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 시간 복잡도는 O(N)으로 매우 빠르게 동작한다.** 

예를 들어, 오름차순 정렬을 수행할 때 이미 오름차순 정렬이 되어있다면
데이터가 들어갈 위치를 고르는 과정에서 단순히 왼쪽 데이터와 한번만 비교하고 바로 멈춘다.
때문에 이 과정이 상수시간(costant time)안에 가능해진다. 
그래서 최선의 경우(이미 정렬이 되어 있는 경우) 전체 정렬을 위한 시간 복잡도는 O(N)이다.


<big>***Big-O Notation: Worst, Avg - O(N²) / Best - O(N)***</big>


### Q. 데이터가 거의 정렬되어 있는 상태에서의 삽입 정렬?

퀵 정렬과 비교했을 때, 보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어있는 상황에서는 퀵 정렬보다 더 강력하다.
**따라서 거의 정렬되어 있는 상태로 입력이 주어지는 문제라면 다른 정렬 알고리즘을 이용하는 것 보다 삽입 정렬을 이용하는 것이 정답 확률을 높일 수 있다.**


## 3. 퀵 정렬

기준을 설정하고 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.


정렬 알고리즘 중에서 가장 많이 사용되는 알고리즘이다. 책에서는 다루지 않지만 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 병합 정렬이 있다. 이 두 알고리즘은 대부분의 프로그래밍 언어에서
정렬 라이브러리의 근간이 되는 알고리즘이기도 하다. 


### 특징
- 큰 숫자와 작은 숫자를 교환할때, 교환하기 위한 기준을 피벗(Pivot)이라고 한다.
- 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야한다.
- 피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분한다.

*여기서는 가장 대표적인 분할 방식인 호어 분할(Hoare Partition)방식을 기준으로 설명한다.*

### 동작 예시 - 호어 분할 방식

- 규칙: 리스트에서 첫 번째 데이터를 피벗으로 정한다.

위의 규칙에 따라 피벗을 설정한 뒤, 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이러한 과정을 반복하면 피벗에 대해 정렬이 수행된다.

초기 데이터: 5 7 9 0 3 1 6 2 4 8

퀵 정렬은 전체 과정을 3개 파트로 나눠보는 것이 편하므로 Ⅰ,Ⅱ,Ⅲ 파트로 설정한다.

#### Ⅰ 파트 - 분할

[step 1] 리스트의 첫 번재 데이터를 피벗으로 설정하므로 피벗은 '5'다. 이후에 왼쪽에서부터 '5'보다 큰 데이터를
선택하므로 '7'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경한다.

5 7 9 0 3 1 6 2 4 8<br>
5 4 9 0 3 1 6 2 7 8

[step 2] 다시 피벗보다 큰 데이터와 작은 데이터를 찾고 두 값의 위치를 서로 변경한다. 현재 '9'와 '2'가 선택되었으므로 이 두 데이터의 위치를 서로 변경한다.

5 4 9 0 3 1 6 2 7 8<br>
5 4 2 0 3 1 6 9 7 8
 
[step 3] 다시 피벗보다 큰 데이터와 작은 데이터를 찾으면 현재 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린다는 것을 알 수 있다.
이렇게 두 값이 엇갈린 경우 '작은 데이터'와 '피벗'의 위치를 서로 변경한다. 즉, 작은 데이터인 '1'과 피벗인 '5'의 위치를 서로 변경하여 분할을 수행한다.

5 4 2 0 3 1 6 9 7 8

[step 4] **분할 완료** 이와 같이 피벗이 이동한 상태에서 왼쪽 리스트와 오른쪽 리스트를 살펴보면, 
피벗인 '5'의 왼쪽에 있는 데이터는 모두 피벗보다 작고 오른쪽에 있는 데이터는 모두 피벗보다 크다.
이러한 작업을 분할(Divide) 혹은 파티션(Partition)이라고 한다.

1 4 2 0 3 5 6 9 7 8

이 상태에서 왼쪽 리스트와 오른쪽 리스트 개별적으로 피벗을 설정하여 동일한 방식으로 정렬을 수행하면
전체 리스트에 대해 모두 정렬이 이루어질 것이다.

#### Ⅱ 파트 - 왼쪽 리스트 정렬

왼쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬 과정은 동일하다.

1 4 2 0 3<br>
1 0 2 4 3<br>
0 1 2 4 3<br>
0 1 2 3 4

#### Ⅲ 파트 - 오른쪽 리스트 정렬

오른쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬 과정은 동일하다.

6 9 7 8<br>
6 7 9 8<br>
6 7 8 9

퀵 정렬은 이처럼 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후에, 피벗을 기준으로 왼쪽리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행한다.
이는 재귀 함수와 동작 원리가 같다. 실제로 퀵 정렬은 재귀 함수 형태로 작성했을 때 구현이 매우 간결해진다. 재귀 함수와 동작 원리가 같다면,
종료 조건이 있어야한다는 것을 알 수 있다. 퀵 정렬의 종료 조건은 바로 현재 리스트의 데이터 개수가 1개인 경우이다. 리스트의 원소가 1개라면,
이미 정렬이 되어 있다고 간주할 수 있으며 분할이 불가능하다. 

### 시간 복잡도

퀵 정렬의 **평균 시간 복잡도는 O(NlogN)**이다.
최선의 경우에 피벗 값의 위치가 변경되어 분할될 때마다 정확히 왼쪽 리스트와 오른쪽 리스트를 절반씩 분할한다면 
도식화 했을 때, 데이터 개수 = N 높이 = logN 이라고 할 수 있다. (일반적으로 컴퓨터 과학에서 log는
밑이 2인 log를 의미한다.) 즉, N = 1,000일 때 log₂N ≈ 10 으로 상대적으로 매우 작은 수임을 이해할 수 있다.

이는 데이터 개수가 많을수록 차이가 극명하게 드러나기때문에 데이터 개수가 많을수록 퀵 정렬은 
선택 정렬, 삽입 정렬에 비해 압도적으로 빠르게 동작할 거라고 추측할 수 있다.

<small>* 아래의 표는 평균 시간 복잡도를 기준으로 각 정렬 알고리즘이 데이터의 개수에 따라 얼마나
많은 연산을 요구하는지를 나타낸 것이다. 엄밀한 연산 횟수 비교는 아니다.</small>

|        데이터 개수(N)   | N²(선택 정렬, 삽입 정렬) |     Nlog₂N(퀵 정렬)     |
|-----------------------|-----------------------|----------------------- |
| N = 1,000             | ≈ 1,000,000           | ≈ 10,000   |
| N = 1,000,000         | ≈ 1,000,000,000,000   | ≈ 20,000,000 |


하지만 퀵 정렬은 **최악의 경우 시간 복잡도가 O(N²)**이다. 데이터가 무작위로 입력될 때 퀵 정렬은 빠르게 동작할 확률이 높지만
위의 예시처럼 가장 왼쪽 데이터를 피벗으로 정할 때는 이미 데이터가 정렬되어 있다면 매우 느리게 동작한다.(
정렬되어 있을 때 매우 빠르게 동작하는 퀵 정렬과는 반대이다.)


<big>***Big-O Notation: Best, Avg - O(NlogN) / Worst - O(N²)</big>


### Q. 라이브러리에서 제공하는 퀵 정렬은 O(NlogN)을 보장하는가?

C++와 같이 퀵 정렬 기반 정렬 라이브러리를 제공하는 프로그래밍 언어들은 최악의 경우에도 시간 복잡도 O(NlogN)을
보장할 수 있도록 피벗 값을 설정할 때 추가적인 로직을 더해준다. 파이썬 또한 마찬가지로 기본 정렬 라이브러리를 이용하면 
O(NlogN)를 보장해준다.


## 4. 계수 정렬

특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘 이다. 모든 데이터가 양의 정수일 때, 데이터의 개수가 N
데이터 중 최댓값이 K일 때, 계수 정렬은 **최악의 경우에도 수행 시간 O(K+N)을 보장**한다. 계수 정렬은 이처럼 매우 빠르게 동작할
뿐만 아니라 원리 또한 매우 간단하다. 다만, 계수 정렬은 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용할 수 있다.

#### 계수 정렬이 효과적인 경우
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 
c.f) 0 이상 100 이하인 성적 데이터를 정렬할 때
  
#### 계수 정렬을 사용할 수 없는 경우
- 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다.
- 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 큰 경우

= 이러한 특징을 가지느 이유는 계수 정렬을 이용할 때 **모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야하기 때문**이다.
다시 말해, 가장 큰 데이터와 가장 작은 데이터가 n만큼 차이난다면 n+1개의 데이터가 들어갈 수 있는 리스트를 초기화해야한다.

직접 데이터의 값을 비교하고 위치를 변경하며 정렬하는 방식(비교 기반 정렬 알고리즘)인 1~3의 알고리즘과 달리 계수 정렬은
같은지 다른지를 비교한다.

계수 정렬은 일반적으로 별도의 리스트를 선언하고(not sorting in place) 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.

### 동작 예시

<small>* 계수 정렬은 데이터의 크기가 제한되어 있을 떄에 한해서 데이터의 개수가 많더라도 빠르게 동작한다.</small>

초기 데이터: 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

계수 정렬은 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.
현재 예시에서는 가장 큰 데이터가 '9'이고 가장 작은 데이터가 '0'이다. 따라서 정렬할 데이터의 범위는 '0'부터 '9'까지
이므로 리스트의 인덱스가 모든 범위를 포함할 수 있도록 크기가 10인 리스트를 선언한다. 그리고 리스트의 모든 데이터를 0으로
초기화한다.

그다음 데이터를 처음부터 하나씩 확인하면서 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수 정렬이 완료된다.

[step 1] **7** 5 9 0 3 1 6 2 9 1 4 8 0 5 2

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|    0   |    0   |      0 |    0   |   0    |   0    |  0     |    0   |    1   |   0    |       

[step 2] **7 5** 9 0 3 1 6 2 9 1 4 8 0 5 2

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|    0   |    0   |      0 |    0   |   0    |   1   |  0     |    0   |    1   |   0    |       

 
[step 3] **7 5 9** 0 3 1 6 2 9 1 4 8 0 5 2

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|    0   |    0   |      0 |    0   |   0    |   1    |  0     |    0   |    1   |   1    |       


<p align="center">
<br>
---------- 중략 ----------
<br>
<br>
</p>

[step 14] **7 5 9 0 3 1 6 2 9 1 4 8 0 5** 2

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|    2   |    2   |    1   |    1   |   1    |   2    |  1     |    1   |    1   |   2    |       

[step 15] **7 5 9 0 3 1 6 2 9 1 4 8 0 5 2**

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|    2   |    2   |    2   |    1   |   1    |   2    |  1     |    1   |    1   |   2    |       

결과적으로 위와 같이 리스트에 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다. 이 리스트에 저장된 데이터 자체가 정렬된 형태
그 자체라고 할 수 있다. 정렬된 결과를 확인하려면 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 인덱스를 출력하면 된다.

c.f) '5' 인덱스의 값은 2이므로 '5'는 2번 등장했다. 그러므로 '5'를 2번 출력하면 된다.
<!--
<table style="border-collapse: collapse; width:100%; height:60px;">
<thead>
  <tr>
	<th style="width:10%;background-color:#808080"><u>0</u></th>
    <th style="width:10%;">1</th>
	<th style="width:10%;">2</th>
	<th style="width:10%;">3</th>
	<th style="width:10%;">4</th>
	<th style="width:10%;">5</th>
	<th style="width:10%;">6</th>
	<th style="width:10%;">7</th>
	<th style="width:10%;">8</th>
	<th style="width:10%;">9</th>
  </tr>
</thead>
<tbody>
 <tr>
  <td style="width:10%;background-color:#808080"><u>2</u></td>
  <td>2</td>
  <td>2</td>
  <td>1</td>
  <td>1</td>
  <td>2</td>
  <td>1</td>
  <td>1</td>
  <td>1</td>
  <td>2</td>
 </tr>
</tbody>
</table>
-->

### 정렬 결과 출력

| <u>0</u> |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| <u>2</u> |  2   |  2   |  1   |  1   |  2   |  1   |  1   |  1   |  2   |
→ 출력 결과: 0 0

| <u>0</u> | <u>1</u>  |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| <u>2</u> | <u>2</u> |  2   |  1   |  1   |  2   |  1   |  1   |  1   |  2   |
→ 출력 결과: 0 0 1 1

<p align="center">
<br>
---------- 중략 ----------
<br>
<br>
</p>

| <u>0</u> | <u>1</u>  |  <u>2   | <u> 3   | <u> 4   |  <u>5   | <u> 6   |  <u>7   |  <u>8 </u>  |  9   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| <u>2</u> | <u>2</u> |  <u>2   |  <u>1   |  <u>1   | <u> 2   |  <u>1   |  <u>1   |  <u>1 </u>  |  2   |
→ 출력 결과: 0 0 1 1


### 시간 복잡도

<big>***Big-O Notation: O(N)***</big>

### Q. 선택 정렬은 효율적인가?






# 추가 알고리즘

이것이 코딩 테스트이다 책에는 나오지 않지만 정렬에 사용되는 알고리즘

## 1. 합병 정렬 (Merge Sort)

## 2. 기수 정렬 (Radix Sort)
<hr>

### 예제

### 실전문제

<br>

[백준 그래프 이론 문제집](https://www.acmicpc.net/problemset?sort=ac_desc&algo=7)

[백준 그래프 탐색 문제집](https://www.acmicpc.net/problemset?sort=ac_desc&algo=11)

[백준 너비 우선 탐색 문제집](https://www.acmicpc.net/problemset?sort=ac_desc&algo=126)

[백준 깊이 우선 탐색 문제집](https://www.acmicpc.net/problemset?sort=ac_desc&algo=127)